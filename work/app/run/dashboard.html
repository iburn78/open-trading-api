<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>OPTRADER Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
</head>
<body style="margin:0; padding:0; font-family:monospace;">
<div id="dashboards"></div>

<script>
const DASHBOARD_MANAGER_PORT = 9020

const dashboards = document.getElementById("dashboards");

// active websockets { port: WebSocket }
const sockets = {};


// ###_ add volume 
// ###_ make it seprate type for manager and server

// HTML panels { port: <pre> }
const panels = {};

function ensurePanel(port, name) {
    if (panels[port]) return panels[port];

    const container = document.createElement("div");
    container.style = "border-bottom:1px solid #ccc; padding:8px";

    const title = document.createElement("div");
    title.textContent = `[${port} - ${name}]`;
    title.style = "font-weight:bold";

    container.appendChild(title);

    let canvas = null;

    // only non-manager / non-server get charts
    if (name !== "manager" && name !== "server") {
        canvas = document.createElement("canvas");
        canvas.height = 200;
        container.appendChild(canvas);
    }

    const pre = document.createElement("pre");
    pre.style = "margin:0; white-space:pre-wrap;";

    container.appendChild(pre);
    dashboards.appendChild(container);

    panels[port] = { 
        pre, 
        canvas, 
        chart: null,
        yMin: null,
        yMax: null
    };
    return panels[port];
}

function ensureChart(panel) {
    if (!panel.canvas) return null;
    if (panel.chart) return panel.chart;

    const ctx = panel.canvas.getContext("2d");

    panel.chart = new Chart(ctx, {
        data: {
            datasets: [
                // price (candlestick)
                {
                    type: "candlestick",
                    label: "Bars",
                    data: []
                },
                // volume
                {
                    type: "bar",
                    label: "Volume",
                    data: [],
                    yAxisID: "volume"
                }
            ]
        },
        options: {
            animation: false,
            parsing: false,
            scales: {
                x: {
                    type: "time"
                },
                y: {
                    position: "left"
                },
                volume: {
                    position: "right",
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false
                    }
                }
            }
        }
    });

    return panel.chart;
}

// for event highlight
const barEventPlugin = {
    id: 'barEventPlugin',

    afterDatasetsDraw(chart) {
        const { ctx } = chart;
        const meta = chart.getDatasetMeta(0); // price dataset
        const data = chart.data.datasets[0].data;

        ctx.save();
        ctx.font = '11px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        meta.data.forEach((elem, i) => {
            const ev = data[i]?.event_;
            if (!ev) return;

            const x = elem.x;
            const y = elem.y - 10; // above candle/bar

            const padding = 4;
            const textW = ctx.measureText(ev).width;
            const w = textW + padding * 2;
            const h = 16;

            // background
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            // if (ev === "BUY") ctx.fillStyle = 'rgba(0,120,255,0.8)'; // use if event_ is defined in multiple ways
            // if (ev === "SELL") ctx.fillStyle = 'rgba(255,80,80,0.8)';
            ctx.fillRect(x - w / 2, y - h, w, h);

            // text
            ctx.fillStyle = '#fff';
            ctx.fillText(ev, x, y - h / 2);
        });

        ctx.restore();
    }
};

Chart.register(barEventPlugin);

// -------- connect a websocket ----------
function connectWS(port, name) {
    if (sockets[port]) return;

    const ws = new WebSocket(`ws://127.0.0.1:${port}`);
    const panel = ensurePanel(port, name);

    ws.onopen = () => {
        panel.textContent = `[${port} - ${name}] Connected\n`;
    };

    // ws.onmessage = event => {
    //     panel.textContent = `[${port} - ${name}]\n` + event.data;
    // };
    ws.onmessage = event => {
        let msg;
        try {
            msg = JSON.parse(event.data);
        } catch {
            panel.pre.textContent = event.data;
            return;
        }

        if (msg.type === "log") {
            panel.pre.textContent = msg.text;
        }
        try {
            if (msg.type === "bars") {
                const chart = ensureChart(panel);
                chart.data.datasets[0].data = msg.bars.map(b => ({
                    x: Date.parse(b.t),
                    o: b.o,
                    h: b.h,
                    l: b.l,
                    c: b.c, 
                    event_: b.event_, 
                }));
                chart.data.datasets[1].data = msg.bars.map(b => ({
                    x: Date.parse(b.t),
                    y: b.v
                }));
                chart.data.datasets[1].backgroundColor = msg.bars.map(b =>
                    b.c >= b.o
                        ? "rgba(0,200,0,0.3)"
                        : "rgba(200,0,0,0.3)"
                );
                // ---- Y-axis bounds logic ----
                const prices = msg.bars.flatMap(b => [b.h, b.l]);
                const curMin = Math.min(...prices);
                const curMax = Math.max(...prices);

                if (panel.yMin === null || curMin < panel.yMin) panel.yMin = curMin;
                if (panel.yMax === null || curMax > panel.yMax) panel.yMax = curMax;

                chart.options.scales.y.min = panel.yMin 
                chart.options.scales.y.max = panel.yMax 

                chart.update();
            }
        } catch (err) {
            panel.pre.textContent = panel.pre.textContent + "\n[CLIENT ERROR]\n" + err.message;
        }
    };

    ws.onclose = () => {
        panel.textContent = `[${port} - ${name}] Connection closed\n`;
    };

    ws.onerror = () => {
        panel.textContent = `[${port} - ${name}] Error\n`;
    };

    sockets[port] = ws;
}

// -------- remove WS + clear panel ----------
function removePort(port) {
    if (sockets[port]) {
        try { sockets[port].close(); } catch(e){}
        delete sockets[port];
    }
    if (panels[port]) {
        panels[port].textContent = ""; // EMPTY
    }
}

// -------- connect to dashboard manager --------
const mgr = new WebSocket(`ws://127.0.0.1:${DASHBOARD_MANAGER_PORT}`);

mgr.onmessage = (event) => {
    let endpoints;
    try {
        endpoints = JSON.parse(event.data); 
    } catch (e) {
        console.error("Invalid manager payload:", event.data);
        return;
    }

    // keys are always strings
    // ports are ordered and showed in that sequence
    const ports = Object.keys(endpoints); 

    // Add / update ports
    ports.forEach(port => {
        connectWS(port, endpoints[port]);
    });

    // Remove ports that no longer exist
    for (const port of Object.keys(sockets)) {
        if (!ports.includes(port)) {  
            removePort(port);  
        }
    }
};

mgr.onopen = () => console.log(`Connected to manager (${DASHBOARD_MANAGER_PORT})`);
mgr.onerror = () => console.log("Manager error");
mgr.onclose = () => console.log("Manager closed");
</script>

</body>
</html>
