<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>OPTRADER Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
</head>
<body style="margin:0; padding:0; font-family:monospace;">
<div id="dashboards"></div>

<script>
const DASHBOARD_MANAGER_PORT = 9020

const dashboards = document.getElementById("dashboards");

// active websockets { port: WebSocket }
const sockets = {};

// HTML panels { port: <pre> }
const panels = {};

function ensurePanel(port, name) {
    if (panels[port]) return panels[port];

    const container = document.createElement("div");
    container.style = "border-bottom:1px solid #ccc; padding:8px";

    const title = document.createElement("div");
    title.textContent = `[${port} - ${name}]`;
    title.style = "font-weight:bold";

    container.appendChild(title);

    let canvas = null;

    // only non-manager / non-server get charts
    if (name !== "manager" && name !== "server") {
        canvas = document.createElement("canvas");
        container.appendChild(canvas);
    }

    const pre = document.createElement("pre");
    pre.style = "margin:0; white-space:pre-wrap;";

    container.appendChild(pre);
    dashboards.appendChild(container);

    panels[port] = { 
        pre, 
        canvas, 
        chart: null,
        yMin: null,
        yMax: null,
        vMax: null,
    };
    return panels[port];
}

function ensureChart(panel) {
    if (!panel.canvas) return null;
    if (panel.chart) return panel.chart;

    const ctx = panel.canvas.getContext("2d");

    panel.chart = new Chart(ctx, {
        data: {
            datasets: [
                // price (candlestick)
                {
                    // type: "ohlc",
                    // barPercentage: 1.1, // use when it is ohlc
                    type: "candlestick", // green: up, red: down (by default)
                    label: "Bars",
                    data: [],
                    borderWidth: 2.5, // candle body outline
                },
                // volume
                {
                    type: "bar",
                    label: "Volume",
                    data: [],
                    yAxisID: "volume",
                    barPercentage: 0.6,
                },
            ]
        },
        options: {
            animation: false,
            parsing: false,
            scales: {
                x: {
                    type: "time"
                },
                y: {
                    position: "left",
                },
                volume: {
                    position: "right",
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false
                    }
                }
            }
        }
    });

    return panel.chart;
}

const EVENT_META = {
    // ---- PRICE ----
    price_surge: {
        label: 'S',
        bg: 'rgba(40,120,255,0.85)',
        fg: '#fff',
    },
    price_plummet: {
        label: 'P',
        bg: 'rgba(220,60,60,0.85)',
        fg: '#fff',
    },
    price_uptrend: {
        label: '↑',
        bg: 'rgba(255,200,40,0.95)',
        fg: '#000',
    },
    price_downtrend: {
        label: '↓',
        bg: 'rgba(160,160,160,0.9)',
        fg: '#000',
    },
    price_surge_uptrend: {
        label: '↑↑',
        bg: 'rgba(0,180,120,0.9)',
        fg: '#fff',
    },
    price_plummet_downtrend: {
        label: '↓↓',
        bg: 'rgba(180,50,50,0.9)',
        fg: '#fff',
    },

    // ---- VOLUME ----
    volume_surge: {
        label: 'V',
        bg: 'rgba(140,80,200,0.85)',
        fg: '#fff',
    },
    volume_uptrend: {
        label: '↗',
        bg: 'rgba(90,170,120,0.85)',
        fg: '#fff',
    },
    volume_surge_uptrend: {
        label: 'V↗',
        bg: 'rgba(110,70,180,0.9)',
        fg: '#fff',
    },

    // ---- MARKET ----
    market_bull: {
        label: '▲',
        bg: 'rgba(255,255,200,0.85)',
        fg: '#000',
        band: 'rgba(255,255,200,0.35)', // background band
    },
    market_bear: {
        label: '▼',
        bg: 'rgba(220,220,220,0.85)',
        fg: '#000',
        band: 'rgba(220,220,220,0.35)',
    },
};

const EVENT_UI = {
    font: '11px monospace',
    padding: 4,
    boxHeight: 16,
    labelOffsetY: 10,
    minBandWidth: 10,
};

// text width cache (font-sensitive)
const _labelWidthCache = new Map();

function getTextWidth(ctx, label) {
    const key = `${ctx.font}|${label}`;
    let w = _labelWidthCache.get(key);
    if (w === undefined) {
        w = ctx.measureText(label).width;
        _labelWidthCache.set(key, w);
    }
    return w;
}

const priceEventPlugin = {
    id: 'priceEventPlugin',

    afterDatasetsDraw(chart) {
        const { ctx } = chart;
        const meta = chart.getDatasetMeta(0);
        const data = chart.data.datasets[0].data;

        ctx.save();
        ctx.font = EVENT_UI.font;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        meta.data.forEach((elem, i) => {
            const key = data[i]?.price_event_;
            if (!key) return;

            const metaDef = EVENT_META[key];
            if (!metaDef) return;

            const label = metaDef.label;
            const x = elem.x;
            const y = elem.y - EVENT_UI.labelOffsetY;

            const textW = getTextWidth(ctx, label);
            const w = textW + EVENT_UI.padding * 2;
            const h = EVENT_UI.boxHeight;

            ctx.fillStyle = metaDef.bg;
            ctx.fillRect(x - w / 2, y - h, w, h);

            ctx.fillStyle = metaDef.fg;
            ctx.fillText(label, x, y - h / 2);
        });

        ctx.restore();
    }
};

const volumeEventPlugin = {
    id: 'volumeEventPlugin',

    afterDatasetsDraw(chart) {
        const { ctx, scales } = chart;
        const meta = chart.getDatasetMeta(1); // volume bars
        const data = chart.data.datasets[1].data;

        ctx.save();
        ctx.font = EVENT_UI.font;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const baseY = scales.volume.getPixelForValue(0);

        meta.data.forEach((elem, i) => {
            const key = data[i]?.volume_event_;
            if (!key) return;

            const metaDef = EVENT_META[key];
            if (!metaDef) return;

            const label = metaDef.label;
            const x = elem.x;
            const y = baseY - EVENT_UI.labelOffsetY;

            const textW = getTextWidth(ctx, label);
            const w = textW + EVENT_UI.padding * 2;
            const h = EVENT_UI.boxHeight;

            // background
            ctx.fillStyle = metaDef.bg;
            ctx.fillRect(x - w / 2, y - h, w, h);

            // text
            ctx.fillStyle = metaDef.fg;
            ctx.fillText(label, x, y - h / 2);
        });

        ctx.restore();
    }
};

const mktEventPlugin = {
    id: 'mktEventPlugin',

    beforeDatasetsDraw(chart) {
        const { ctx, chartArea } = chart;
        if (!chartArea) return;
        const meta = chart.getDatasetMeta(0);
        const data = chart.data.datasets[0].data;

        ctx.save();

        meta.data.forEach((elem, i) => {
            const key = data[i]?.mkt_event_;
            if (!key) return;

            const metaDef = EVENT_META[key];
            if (!metaDef) return;

            const x = elem.x;

            let w = EVENT_UI.minBandWidth;
            if (meta.data.length > 1) {
                w =
                    i < meta.data.length - 1
                        ? meta.data[i + 1].x - elem.x
                        : elem.x - meta.data[i - 1].x;
            }

            // background band
            ctx.fillStyle = metaDef.band;
            ctx.fillRect(
                x - w / 2,
                chartArea.top,
                w,
                chartArea.bottom - chartArea.top
            );

            // label box
            ctx.font = EVENT_UI.font;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const textW = getTextWidth(ctx, label);
            const boxW = textW + EVENT_UI.padding * 2;
            const boxH = EVENT_UI.boxHeight;

            ctx.fillStyle = metaDef.bg;
            ctx.fillRect(
                x - boxW / 2,
                chartArea.top + 2,
                boxW,
                boxH
            );

            ctx.fillStyle = metaDef.fg;
            ctx.fillText(
                metaDef.label,
                x,
                chartArea.top + 2 + boxH / 2
            );
        });

        ctx.restore();
    }
};

Chart.register(priceEventPlugin);
Chart.register(volumeEventPlugin);
Chart.register(mktEventPlugin);

// Order:
// 1) mktEventPlugin  → background bands
// 2) chart datasets
// 3) price / volume overlays

// -------- connect a websocket ----------
function connectWS(port, name) {
    if (sockets[port]) return;

    const ws = new WebSocket(`ws://127.0.0.1:${port}`);
    const panel = ensurePanel(port, name);

    ws.onopen = () => {
        panel.pre.textContent = `[${port} - ${name}] Connected\n`;
    };

    ws.onmessage = event => {
        let msg;
        try {
            msg = JSON.parse(event.data);
        } catch {
            panel.pre.textContent = event.data;
            return;
        }

        if (msg.type === "log") {
            panel.pre.textContent = msg.text;
        }
        try {
            if (msg.type === "bars") {
                const chart = ensureChart(panel);
                chart.data.datasets[0].data = msg.bars.map(b => ({
                    x: Date.parse(b.t),
                    o: b.o,
                    h: b.h,
                    l: b.l,
                    c: b.c, 
                    price_event_: b.price_event_, 
                    mkt_event_: b.mkt_event_, 
                }));
                chart.data.datasets[1].data = msg.bars.map(b => ({
                    x: Date.parse(b.t),
                    y: b.v,
                    volume_event_: b.volume_event_, 
                }));
                chart.data.datasets[1].backgroundColor = "rgba(128, 128, 128, 0.5)" // gray
                // chart.data.datasets[1].backgroundColor = msg.bars.map(b =>
                //     b.c >= b.o
                //         ? "rgba(0,200,0,0.3)"
                //         : "rgba(200,0,0,0.3)"
                // );
                // ---- Y-axis bounds logic ----
                const prices = msg.bars.flatMap(b => [b.h, b.l]);
                const curMin = Math.min(...prices);
                const curMax = Math.max(...prices);

                if (panel.yMin === null || curMin < panel.yMin) panel.yMin = curMin;
                if (panel.yMax === null || curMax > panel.yMax) panel.yMax = curMax;

                chart.options.scales.y.min = panel.yMin 
                chart.options.scales.y.max = panel.yMax 

                const vols = msg.bars.map(b => b.v);
                const vMax = Math.max(...vols);

                if (panel.vMax === null || vMax > panel.vMax) panel.vMax = vMax;
                chart.options.scales.volume.max = panel.vMax;

                chart.update();
            }
        } catch (err) {
            panel.pre.textContent = panel.pre.textContent + "\n[CLIENT ERROR]\n" + err.message;
        }
    };

    ws.onclose = () => {
        panel.pre.textContent = `[${port} - ${name}] Connection closed\n`;
    };

    ws.onerror = () => {
        panel.pre.textContent = `[${port} - ${name}] Error\n`;
    };

    sockets[port] = ws;
}

// -------- remove WS + clear panel ----------
function removePort(port) {
    if (sockets[port]) {
        try { sockets[port].close(); } catch(e){}
        delete sockets[port];
    }
    if (panels[port]) {
        panels[port].textContent = ""; // EMPTY
    }
}

// -------- connect to dashboard manager --------
const mgr = new WebSocket(`ws://127.0.0.1:${DASHBOARD_MANAGER_PORT}`);

mgr.onmessage = (event) => {
    let endpoints;
    try {
        endpoints = JSON.parse(event.data); 
    } catch (e) {
        console.error("Invalid manager payload:", event.data);
        return;
    }

    // keys are always strings
    // ports are ordered and showed in that sequence
    const ports = Object.keys(endpoints); 

    // Add / update ports
    ports.forEach(port => {
        connectWS(port, endpoints[port]);
    });

    // Remove ports that no longer exist
    for (const port of Object.keys(sockets)) {
        if (!ports.includes(port)) {  
            removePort(port);  
        }
    }
};

mgr.onopen = () => console.log(`Connected to manager (${DASHBOARD_MANAGER_PORT})`);
mgr.onerror = () => console.log("Manager error");
mgr.onclose = () => console.log("Manager closed");
</script>

</body>
</html>
